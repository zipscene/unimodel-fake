const { SchemaModel } = require('zs-unimodel');
const { createQuery } = require('zs-common-query');
const { createSchema } = require('zs-common-schema');
const FakeDocument = require('./fake-document');
const { deepCopy, setPath, getPath, ObjectMask } = require('zs-objtools');
const _ = require('lodash');
const AggregateEvaluation = require('./aggregate-evaluation');
const { multiFieldSort } = require('./utils');

class FakeModel extends SchemaModel {

	constructor(name, schema, options = {}) {
		schema = createSchema(schema).getData();
		schema.properties._id = { type: 'number' };
		super(schema, options);
		// Array of "documents" in this fake database (ie, document datas - actual FakeDocument
		// classes are generated by the retrieval methods)
		this._documents = [];
		// Counter of _id's
		this._idCtr = 1;
		this._fakeModelName = name;
	}

	getName() {
		return this._fakeModelName;
	}

	find(query, options = {}) {
		if (_.isPlainObject(query)) query = createQuery(query);
		// Filter documents by whether or not they match the query
		let results = _.filter(this._documents, (doc) => {
			return query.matches(doc);
		});
		// Sort
		if (options.sort) {
			results = multiFieldSort(results, options.sort);
		}
		// Filter out fields
		if (options.fields) {
			let maskData = {};
			for (let field of options.fields) {
				setPath(maskData, field, true);
			}
			setPath(maskData, '_id', true);
			let mask = new ObjectMask(maskData);
			results = _.map(results, (doc) => {
				return mask.filterObject(doc);
			});
		}
		// Save total
		let total = results.length;
		// Apply skip and limit
		if (options.skip !== undefined) {
			results = results.slice(options.skip);
		}
		if (options.limit !== undefined) {
			results = results.slice(0, options.limit);
		}
		// Convert to documents
		results = _.map(results, (doc) => {
			return new FakeDocument(this, doc);
		});
		// Set total field
		if (options.total) {
			results.total = total;
		}
		// Return results inside a promise
		return Promise.resolve(results);
	}

	create(data = {}) {
		if (!data._id) {
			data._id = this._idCtr++;
		}
		return new FakeDocument(this, data);
	}

	insert(data) {
		let doc = this.create(data);
		return doc.save().then(() => doc);
	}

	clear() {
		this._documents = [];
	}

	aggregate(query, aggregate, options = {}) {
		return this.find(query, { limit: options.scanLimit })
			.then((docs) => {
				let aggrEval = new AggregateEvaluation(docs, aggregate, options);
				return aggrEval.evaluate();
			});
	}

}

module.exports = FakeModel;

